/*
 * st_pthread_pool.c
 *
 *  Created on: 2011-12-6
 *      Author: kine
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include "st_pthread_pool.h"

/*	局部函数声明	*/
static void *thread_routine (void *arg);

/*	全局变量声明	*/
static CThread_pool *pool = NULL;


/*	接口函数定义	*/
void pool_init (int max_thread_num)
{
	int i = 0;

	pool = (CThread_pool *) malloc (sizeof (CThread_pool));

	pthread_mutex_init (&(pool->queue_lock), NULL);
	pthread_cond_init (&(pool->queue_ready), NULL);

	pool->queue_head = NULL;

	pool->max_thread_num = max_thread_num;		// 线程池的大小
	pool->cur_queue_size = 0;

	pool->shutdown = 0;							// 线程池是否销毁的标志
	// 分配连续id空间
	pool->threadid = (pthread_t *) malloc (max_thread_num * sizeof (pthread_t));

	// 连续创建三个线程句柄;线程池的概念是线程句柄的复用
	for (i = 0; i < max_thread_num; i++)
	{
		pthread_create (&(pool->threadid[i]), NULL, thread_routine, NULL);
	}
}




/*销毁线程池，等待队列中的任务不会再被执行，但是正在运行的线程会一直把任务运行完后再退出*/
int pool_destroy (void)
{
	int i;

	if (pool->shutdown)
		return -1;/*防止两次调用*/

	pool->shutdown = 1;

	/*唤醒所有等待线程，线程池要销毁了*/
	pthread_cond_broadcast (&(pool->queue_ready));

	/*阻塞等待线程退出，否则就成僵尸了*/
	for (i = 0; i < pool->max_thread_num; i++)
		pthread_join (pool->threadid[i], NULL);

	free (pool->threadid);

	/*销毁等待队列*/
	CThread_worker *head = NULL;
	while (pool->queue_head != NULL)
	{
		head = pool->queue_head;
		pool->queue_head = pool->queue_head->next;
		free (head);
	}
	/*条件变量和互斥量也别忘了销毁*/
	pthread_mutex_destroy(&(pool->queue_lock));
	pthread_cond_destroy(&(pool->queue_ready));

	free (pool);
	/*销毁后指针置空是个好习惯*/
	pool=NULL;
	return 0;
}

/*向线程池中加入任务*/
int pool_add_worker (void *(*process) (void *arg), void *arg)
{
	/*构造一个新任务*/
	CThread_worker *newworker = (CThread_worker *) malloc (sizeof (CThread_worker));
	newworker->process = process;				// 任务实现
	newworker->arg = arg;
	newworker->next = NULL;/*别忘置空*/

	pthread_mutex_lock (&(pool->queue_lock));
	/*将任务加入到等待队列中*/
	CThread_worker *member = pool->queue_head;
	if (member != NULL)					// 队列不为空的时候
	{
		while (member->next != NULL)
		{
			member = member->next;
		}

		member->next = newworker;		// new work 加入队列
	}
	else
	{
		pool->queue_head = newworker;
	}

	assert (pool->queue_head != NULL);

	pool->cur_queue_size++;				// 队列大小+1
	pthread_mutex_unlock (&(pool->queue_lock));
	/*好了，等待队列中有任务了，唤醒一个等待线程；注意如果所有线程都在忙碌，这句没有任何作用*/
	pthread_cond_signal (&(pool->queue_ready));
	return 0;
}

/*	局部函数定义	*/
static void *thread_routine (void *arg)
{
	printf ("starting thread 0x%x\n", pthread_self ());
	while (1)
	{
		pthread_mutex_lock (&(pool->queue_lock));		// 上锁后不能再操作此数据区域
		printf("haha\n");
		/*如果等待队列为0并且不销毁线程池，则处于阻塞状态; 注意
		pthread_cond_wait是一个原子操作，等待前会解锁，唤醒后会加锁*/
		while (pool->cur_queue_size == 0 && !pool->shutdown)
		{
			printf ("thread 0x%x is waiting\n", pthread_self ());

			pthread_cond_wait (&(pool->queue_ready), &(pool->queue_lock));	// 等待任务的信号
		}

		/*线程池要销毁了*/
		if (pool->shutdown)
		{
			/*遇到break,continue,return等跳转语句，千万不要忘记先解锁*/
			pthread_mutex_unlock (&(pool->queue_lock));
			printf ("thread 0x%x will exit\n", pthread_self ());
			pthread_exit (NULL);
		}

		printf ("thread 0x%x is starting to work\n", pthread_self ());

		/*assert是调试的好帮手*/
		assert (pool->cur_queue_size != 0);
		assert (pool->queue_head != NULL);

		/*等待队列长度减去1，并取出链表中的头元素*/
		pool->cur_queue_size--;
		CThread_worker *worker = pool->queue_head;		// 获取队列的一个任务
		pool->queue_head = worker->next;
		pthread_mutex_unlock (&(pool->queue_lock));

		/*调用回调函数，执行任务*/
		(*(worker->process)) (worker->arg);
		free (worker);
		worker = NULL;
	}
	/*这一句应该是不可达的*/
	pthread_exit (NULL);
}

