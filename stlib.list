=================================================================================
= 标题: stlib 简介
= 版本: 1.0 (build 2011.06.28)
=================================================================================
  

stlib 提供丰富的函数 如
1.slist.
2.dlist.
3.queue.
4.hash.(常用字符串哈希函数有BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash等等)
5.arry（数组，向量）
6.tree（huffman，Btree,b-tree，rbtree,treap,splay, b-, b+, b*, rtree）
7.大数运算
8.crc
9.string	(实现各种string函数，strstr， strrchr)
10.stlog
11.mempool
12.thread


//----------------------------
常见算法时间复杂度：
O(1): 表示算法的运行时间为常量
O(n): 表示该算法是线性算法
O(S2 n)/O(lgn): 二分查找算法
O(n2 ): 对数组进行排序的各种简单算法，例如直接插入排序的算法。
O(n3 ): 做两个n阶矩阵的乘法运算
O(2n ): 求具有n个元素集合的所有子集的算法
O(n!): 求具有N个元素的全排列的算法
优<---------------------------<劣
O(1)<O(S2 n)<O(n)<O(n2 )<O(2n )
时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2 n)、线性阶O(n)、线性对数阶O(nlog2 n)、平方阶O(n2 )、立方阶O(n3 )、……k次方阶O(nk )、指数阶O(2n )。

//-------------平衡树---------------
			
btree
bstree
bbstree
splaytree
treap
rbtree

各种平衡树的旋转伪代码:
(avl,splay,st_rbtree,treap):
左旋转：
right = node->rchild ;
node->rchild = right->lchild ;
right->lchild = node ;
右旋转：
left = node->lchild ;
node->lchild = left->rchild ;
left->rchild = node ;

//----------b-树（多路平衡树）
B 树又叫平衡多路查找树。一棵m阶的B 树 (m叉树)的特性如下：
树中每个结点最多含有m个孩子（m>=2）；
除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；
若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；
所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；
每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：
       a)   Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。 
       b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 
       c)   关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。
（1）每个非根的结点必须至少含有t-1个关键字。每个非根的内结点至少有t个子女。如果树是非空的，则根结点至少包含一个关键字；
（2）每个结点可包含之多2t-1个关键字。所以一个内结点至多可有2t个子女。如果一个结点恰好有2t-1个关键字，我们就说这个结点是满的（而稍后介绍的B*树作为B树的一种常用变形，B*树中要求每个内结点至少为2/3满，而不是像这里的B树所要求的至少半满）；
（3）当关键字数t=2（t=2的意思是，tmin=2，t可以>=2）时的B树是最简单的（有很多人会因此误认为B树就是二叉查找树，但二叉查找树就是二叉查找树，B树就是B树，B树的真正最准确的定义为：一棵含有t（t>=2）个关键字的平衡多路查找树）。每个内结点可能因此而含有2个、3个或4个子女，亦即一棵2-3-4树，然而在实际中，通常采用大得多的t值。

//------------------------------
B+-tree：是应文件系统所需而产生的一种B-tree的变形树。
一棵m阶的B+树和m阶的B树的差异在于：
      1.有n棵子树的结点中含有n个关键字； (而B 树是n棵子树有n-1个关键字)
      2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)
      3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)
      
a)为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？
1) B+-tree的磁盘读写代价更低
	B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
    举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。
2) B+-tree的查询效率更加稳定
	由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
	
//---------------------------------
B*-tree
B*-tree是B+-tree的变体，在B+ 树非根和非叶子结点再增加指向兄弟的指针；B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）	

小结
       B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；
       B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；
       所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
       B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
       B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；


//-------------------------------
//散列哈希表：
(分离链接和开放定址)
散列表的大小最好是素数
处理冲突的方法  

　通常有两类方法处理冲突：开放定址(Open Addressing)法和拉链(Chaining)法。前者是将所有结点均存放在散列表T[0..m-1]中；后者通常是将互为同义词的结点链成一个单链表，而将此链表的头指针放在散列表T[0..m-1]中。

1、开放定址法
（1）开放地址法解决冲突的方法
　用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。
注意：
①用开放定址法建立散列表时，建表前须将表中所有单元(更严格地说，是指单元中存储的关键字)置空。
②空单元的表示与具体的应用相关。
【例】关键字均为非负数时，可用"-1"来表示空单元，而关键字为字符串时，空单元应是空串。
总之：应该用一个不会出现的关键字来表示空单元。

（2）开放地址法的一般形式
开放定址法的一般形式为： hi=(h(key)+di)％m 1≤i≤m-1  
其中：
　 ①h(key)为散列函数，di为增量序列，m为表长。
　②h(key)是初始的探查位置，后续的探查位置依次是hl，h2，…，hm-1，即h(key)，hl，h2，…，hm-1形成了一个探查序列。
　 ③若令开放地址一般形式的i从0开始，并令d0=0，则h0=h(key)，则有：
hi=(h(key)+di)％m 0≤i≤m-1  
探查序列可简记为hi(0≤i≤m-1)。

（3）开放地址法堆装填因子的要求
　开放定址法要求散列表的装填因子α≤l，实用中取α为0.5到0.9之间的某个值为宜。

（4）形成探测序列的方法
　按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。
①线性探查法(Linear Probing)
该方法的基本思想是：
将散列表T[0..m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：
d，d+l，d+2，…，m-1，0，1，…，d-1
　即:探查时从地址d开始，首先探查T[d]，然后依次探查T[d+1]，…，直到T[m-1]，此后又循环到T[0]，T[1]，…，直到探查到T[d-1]为止。

探查过程终止于三种情况：
	(1)若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）；
	(2)若当前探查的单元中含有key，则查找成功，但对于插入意味着失败；
	(3)若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。

利用开放地址法的一般形式，线性探查法的探查序列为：
hi=(h(key)+i)％m 0≤i≤m-1 //即di=i

利用线性探测法构造散列表
【例9.1】已知一组关键字为(26，36，41，38，44，15，68，12，06，51)，用除余法构造散列函数，用线性探查法解决冲突构造这组关键字的散列表。
解答:为了减少冲突，通常令装填因子α
　由除余法的散列函数计算出的上述关键字序列的散列地址为(0，10，2，12，5，2，3，12，6，12)。
　前5个关键字插入时，其相应的地址均为开放地址，故将它们直接插入T[0]，T[10)，T[2]，T[12]和T[5]中。
　当插入第6个关键字15时，其散列地址2(即h(15)=15％13=2)已被关键字41(15和41互为同义词)占用。故探查h1=(2+1)％13=3，此地址开放，所以将15放入T[3]中。
　当插入第7个关键字68时，其散列地址3已被非同义词15先占用，故将其插入到T[4]中。
　当插入第8个关键字12时，散列地址12已被同义词38占用，故探查hl=(12+1)％13=0，而T[0]亦被26占用，再探查h2=(12+2)％13=1，此地址开放，可将12插入其中。
　类似地，第9个关键字06直接插入T[6]中；而最后一个关键字51插人时，因探查的地址12，0，1，…，6均非空，故51插入T[7]中。
　构造散列表的具体过程【参见动画演示】

聚集或堆积现象
用线性探查法解决冲突时，当表中i,i+1，…，i+k的位置上已有结点时，一个散列地址为i，i+1，…，i+k+1的结点都将插入在位置i+k+1 上。把这种散列地址不同的结点争夺同一个后继散列地址的现象称为聚集或堆积(Clustering)。这将造成不是同义词的结点也处在同一个探查序列之 中，从而增加了探查序列的长度，即增加了查找时间。若散列函数不好或装填因子过大，都会使堆积现象加剧。
【例】上例中，h(15)=2，h(68)=3，即15和68不是同义词。但由于处理15和同义词41的冲突时，15抢先占用了T[3]，这就使得插入68时，这两个本来不应该发生冲突的非同义词之间也会发生冲突。
　为了减少堆积的发生，不能像线性探查法那样探查一个顺序的地址序列(相当于顺序查找)，而应使探查序列跳跃式地散列在整个散列表中。

②二次探查法(Quadratic Probing)
　二次探查法的探查序列是：
hi=(h(key)+i*i)％m 0≤i≤m-1 //即di=i2
即探查序列为d=h(key)，d+12，d+22，…，等。
　该方法的缺陷是不易探查到整个散列空间。

③双重散列法(Double Hashing)
　该方法是开放定址法中最好的方法之一，它的探查序列是：
hi=(h(key)+i*h1(key))％m 0≤i≤m-1 //即di=i*h1(key)
　即探查序列为：
d=h(key)，(d+h1(key))％m，(d+2h1(key))％m，…，等。
　该方法使用了两个散列函数h(key)和h1(key)，故也称为双散列函数探查法。
注意：
定义h1(key)的方法较多，但无论采用什么方法定义，都必须使h1(key)的值和m互素，才能使发生冲突的同义词地址均匀地分布在整个表中，否则可能造成同义词地址的循环计算。
【例】若m为素数，则h1(key)取1到m-1之间的任何数均与m互素，因此，我们可以简单地将它定义为：
h1(key)=key％(m-2)+1
【例】对例9.1，我们可取h(key)=key％13，而h1(key)=key％11+1。
【例】若m是2的方幂，则h1(key)可取1到m-1之间的任何奇数。

2、拉链法
（1）拉链法解决冲突的方法
　拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。

【例9.2】已知一组关键字和选定的散列函数和例9.1相同，用拉链法解决冲突构造这组关键字的散列表。
解答：不妨和例9.1类似，取表长为13，故散列函数为h(key)=key％13，散列表为T[0..12]。
注意：
当把h(key)=i的关键字插入第i个单链表时，既可插入在链表的头上，也可以插在链表的尾上。这是因为必须确定key不在第i个链表时，才能将它插入 表中，所以也就知道链尾结点的地址。若采用将新关键字插入链尾的方式，依次把给定的这组关键字插入表中，则所得到的散列表如下图所示。
　具体构造过程【参见动画演示】。

（2）拉链法的优点
　与开放定址法相比，拉链法有如下几个优点：
(1)拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
(2)由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
(3)开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
(4)在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将 被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。 因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

（3）拉链法的缺点
　拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。







