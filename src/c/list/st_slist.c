#include <stdlib.h>
#include <stdio.h>
#include "st_slist.h"




/*-------------------------------------------------------------------------*
Function:	st_slist_last
Created By:   è´©stjq
Created Date: è´?011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
stpointer data
Returns:
STSList
Discription:
get the last node of the list
 *-------------------------------------------------------------------------*/
STSList*  st_slist_last(STSList *list)
{
	if(NULL != list)
	{
		while(NULL != list->next)
		{
			list = list->next ;
		}
	}

	return list ;
}


static STSList *
st_slist_sort_merge (STSList   *l1, 
		STSList   *l2,
		STFunc     compare_func,
		stpointer  user_data)
{
	STSList list, *l;
	stint cmp;

	l=&list;

	while (l1 && l2)
	{
		cmp = ((STCompareDataFunc) compare_func) (l1->data, l2->data, user_data);

		if (cmp <= 0)
		{
			l=l->next=l1;
			l1=l1->next;
		} 
		else 
		{
			l=l->next=l2;
			l2=l2->next;
		}
	}
	l->next= l1 ? l1 : l2;

	return list.next;
}

static STSList *
st_slist_sort_real (STSList   *list,
		STFunc     compare_func,
		stpointer  user_data)
{
	STSList *l1, *l2;

	if (!list) 
		return NULL;
	if (!list->next) 
		return list;

	l1 = list; 
	l2 = list->next;

	while ((l2 = l2->next) != NULL)
	{
		if ((l2 = l2->next) == NULL) 
			break;
		l1=l1->next;
	}
	l2 = l1->next; 
	l1->next = NULL;

	return st_slist_sort_merge (st_slist_sort_real (list, compare_func, user_data),
			st_slist_sort_real (l2, compare_func, user_data),
			compare_func,
			user_data);	
}



/*-------------------------------------------------------------------------*
Function:	st_slist_sort
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
STCompareFunc compare_func
Returns:
STSList						### the new start of the SList
Discription:
Sorts a #GSList using the given comparison function.
 *-------------------------------------------------------------------------*/
STSList* st_slist_sort(STSList *list, STCompareFunc compare_func)
{
	return st_slist_sort_real (list, (STFunc) compare_func, NULL);
}

/*-------------------------------------------------------------------------*
Function:	st_slist_sort_with_data
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
STCompareFunc compare_func
Returns:
STSList						### the new start of the SList
Discription:
Sorts a #GSList using the given comparison function.
 *-------------------------------------------------------------------------*/
STSList*  st_slist_sort_with_data          (STSList           *list,
		STCompareDataFunc  compare_func,
		stpointer          user_data)
{
	return st_slist_sort_real (list, (STFunc) compare_func, user_data);
}



/*-------------------------------------------------------------------------*
Function:	st_slist_foreach
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
STFunc func, 
stpointer user_data
Returns:
STSList						### the new start of the SList
Discription:
Calls a function for each element of a #GSList
 *-------------------------------------------------------------------------*/
void st_slist_foreach(STSList *list, STFunc func, stpointer user_data)
{
	while(NULL != list)
	{
		(*func)(list->data, user_data) ;
		list = list->next ;
	}
}




/*-------------------------------------------------------------------------*
Function:	st_slist_length
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
Returns:
STSList						### the new start of the SList
Discription:
This function iterates over the whole list to 
 * count its elements.
 *-------------------------------------------------------------------------*/
stuint st_slist_length(STSList *list)
{
	stuint length ;

	length = 0 ;

	while(NULL != list)
	{
		length++ ;
		list = list->next ;
	}	

	return length ;
}




/*-------------------------------------------------------------------------*
Function:	st_slist_position
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
STSList *llink
Returns:
STSList						### the new start of the SList
Discription:
Gets the position of the given element 
 * in the SList (starting from 0).
 *-------------------------------------------------------------------------*/
stint st_slist_position(STSList *list, STSList *llink)
{
	stint i = 0 ;

	while(NULL != list)
	{
		if(list == llink)
			return i ;

		i++ ;
		list = list->next ;
	}

	return -1 ;
}


/*-------------------------------------------------------------------------*
Function:	st_slist_find
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
stuint n
Returns:
STSList						### the new start of the SList
Discription:
Finds the element in a SList which 
 * contains the given data.
 *-------------------------------------------------------------------------*/
STSList*  st_slist_find(STSList *list, stconstpointer data)
{
	while(NULL != list)
	{
		if(list->data == data)
			break ;
		list = list->next ;
	}	

	return list ;
}


/*-------------------------------------------------------------------------*
Function:	st_slist_nth
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
stuint n
Returns:
STSList						### the new start of the SList
Discription:
Gets the element at the given position in a SList.
 *-------------------------------------------------------------------------*/
STSList*  st_slist_nth(STSList *list, stuint n)
{
	while(n-- && list)
		list = list->next ;

	return list ;
}


/*-------------------------------------------------------------------------*
Function:	st_slist_nth_data
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
stuint n
Returns:
STSList						### the new start of the SList
Discription:
Gets the data of the element at the given position.
 *-------------------------------------------------------------------------*/
stpointer st_slist_nth_data(STSList *list, stuint n)
{
	while(n-- && list)
		list = list->next ;

	return list ? list->data : NULL ;
}



/*-------------------------------------------------------------------------*
Function:	st_slist_copy
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
Returns:
STSList						### the new start of the SList
Discription:
Note that this is a "shallow" copy. If the list elements 
 * consist of pointers to data, the pointers are copied but 
 * the actual data isn't.
 *-------------------------------------------------------------------------*/
STSList*  st_slist_copy(STSList *list)
{
	STSList *new_list = NULL ;

	if(NULL != list)
	{
		STSList *last = NULL ;

		new_list = st_slist_alloc();
		new_list->data = list->data ;
		last = new_list ;
		list = list->next ;

		while(NULL != list)
		{
			last->next = st_slist_alloc();
			last = last->next ;
			last->data = list->data ;
			list = list->next ;
		}
		list->next = NULL ;
	}


	return new_list ;
}


/*-------------------------------------------------------------------------*
Function:	st_slist_reverse
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
Returns:
STSList						### the new start of the SList
Discription:
Reverses a list
 *-------------------------------------------------------------------------*/
/*
list 2 3 5 6 7			list
next 3 5 6 7 			next = list->next
list 2					list->next = prev
prev 2					prev = list
list = 3 5 6 7			list = next

list 3 5 6 7
next 5 6 7 
list 3 2
prev 3 2
list = 5 6 7

list 5 6 7
next 6 7 
list 5 3 2
prev 5 3 2
list = 6 7

list 6 7
next 7 
list 6 5 3 2
prev 6 5 3 2
list = 7

list 7
next NULL 
list 7 6 5 3 2
prev 7 6 5 3 2
list = NULL
*/
STSList*  st_slist_reverse(STSList *list)
{
	STSList *prev = NULL ;

	while(NULL != list)
	{
		STSList *next = list->next ;
		
		list->next = prev ;
		prev = list ;
		list = next ;
	}

	return list ;
}



static /*inline*/ STSList*
_st_slist_remove_link (STSList *list,
		STSList *link)
{
	STSList *temp = NULL ;
	STSList *prev = NULL ;

	temp = list ;

	while(NULL != temp)
	{
		if(temp == link)
		{
			if(NULL != prev)
			{
				prev->next = temp->next ;
			}	
			if(list == temp)
			{
				list = list->next ;
			}	
			temp->next = NULL ;
			break ;
		}
		prev = temp ;
		temp = temp->next ;
	}

	return list ;
}


/*-------------------------------------------------------------------------*
Function:	st_slist_delete_link
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list1		
STSList *link_
Returns:
STSList						### the new start of the SList
Discription:
Removes the node link_ from the list and frees it. 
 * Compare this to g_slist_remove_link() which removes the node 
 * without freeing it.
 *-------------------------------------------------------------------------*/
STSList*  st_slist_delete_link(STSList *list, STSList *link_)

{
	list = _st_slist_remove_link (list, link_);
	free(link_) ;
	link_ = NULL ;

	return list ;
}

/*-------------------------------------------------------------------------*
Function:	st_slist_remove_link
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list1		
STSList *link_
Returns:
STSList						### the new start of the SList
Discription:
Removes an element from a #GSList, without 
 * freeing the element. The removed element's next 
 * link is set to %NULL, so that it becomes a
 * self-contained list with one element.
 *-------------------------------------------------------------------------*/
STSList*  st_slist_remove_link(STSList *list, STSList *link_)
{
	return _st_slist_remove_link (list, link_);
}

/*-------------------------------------------------------------------------*
Function:	st_slist_remove_all
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list1		
stconstpointer data
Returns:
STSList						### the new start of the SList
Discription:
Removes all list nodes with data equal to @data. 
 * Returns the new head of the list. Contrast with 
 * g_slist_remove() which removes only the first node 
 * matching the given data.
 *-------------------------------------------------------------------------*/
STSList*  st_slist_remove_all(STSList *list, stconstpointer data) 
{
	STSList *prev = NULL ;
	STSList *temp = NULL ;

	temp = list ;

	while(NULL != temp)
	{
		if(temp->data == data)
		{
			//STSList *next = temp->next ;
			if(NULL != prev)
			{
				prev = temp->next ;
			}
			else
			{
				list = temp->next ;
			}
			free(temp);
			temp = NULL ;
			temp = temp->next ;
		}
		else
		{
			prev = temp ;
			temp = temp->next ;
		}	
	}	
}


/*-------------------------------------------------------------------------*
Function:	st_slist_remove
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list1		
stconstpointer data
Returns:
STSList						### the new start of the SList
Discription:
Removes an element from a SList.
 * If two elements contain the same data, only the first is removed.
 * If none of the elements contain the data, the SList is unchanged.
 *
 *-------------------------------------------------------------------------*/
STSList*  st_slist_remove(STSList *list, stconstpointer data)
{
	STSList *prev = NULL ;		// ±£´æÇ°Ò»¸öÖ¸Õë£¬ÓÃÓÚÁ¬½ÓÓÃ
	STSList *temp = NULL ;

	temp = list ;

	while(NULL != temp)
	{
		if(temp->data == data)
		{
			if(NULL != prev)	// prev ²»Îª¿Õ£¬ÎªÖÐ¼ä½Úµã
			{
				prev->next = temp->next ;
			}
			else		// prev Îª¿Õ£¬¼´µÚÒ»½Úµã
			{
				list = temp->next ;
			}	
			free(temp);
			temp = NULL ;
			break ;		// É¾³ýµÚÒ»¸öºó¾Íbreak
		}
		prev = temp ;
		temp = temp->next ;
	}	

	return list ;
}


/*-------------------------------------------------------------------------*
Function:	st_slist_concat
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list1		
STSList *list2				### SList to add to the end of the first
Returns:
STSList						### the new start of the SList
Discription:
Adds the second #GSList onto the end of the first #GSList.
 * Note that the elements of the second #GSList are not copied.
 * They are used directly.
 *-------------------------------------------------------------------------*/
STSList*  st_slist_concat(STSList *list1, STSList *list2)
{
	if(NULL != list2)
	{
		if(NULL != list1)
		{
			st_slist_last(list1)->next = list2 ;
		}	
		else 
		{
			list1 = list2 ;
		}
	}	

	return list1 ;
}


static STSList*
st_slist_insert_sorted_real (STSList   *list,
		stpointer  data,
		STFunc     func,
		stpointer  user_data)
{
	STSList *tmp_list = list;
	STSList *prev_list = NULL;
	STSList *new_list;
	stint cmp;


	if (!list)
	{
		new_list = st_slist_alloc ();
		new_list->data = data;
		new_list->next = NULL;
		return new_list;
	}

	cmp = ((STCompareDataFunc) func) (data, tmp_list->data, user_data);

	while ((tmp_list->next) && (cmp > 0))	// fit the position: end of the list or cmp < 0
	{
		prev_list = tmp_list;
		tmp_list = tmp_list->next;

		cmp = ((STCompareDataFunc) func) (data, tmp_list->data, user_data);
	}

	// create a new list
	new_list = st_slist_alloc ();
	new_list->data = data;

	if ((!tmp_list->next) && (cmp > 0))
	{
		tmp_list->next = new_list;
		new_list->next = NULL;
		return list;
	}

	if (prev_list)
	{
		prev_list->next = new_list;
		new_list->next = tmp_list;
		return list;
	}
	else
	{
		new_list->next = list;
		return new_list;
	}
}

/*-------------------------------------------------------------------------*
Function:	st_slist_insert_sorted
Created By:   stjq
Created Date: 2011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
stpointer data				### the data for the new element
stint position				### the position to insert the element. 
Returns:
STSList						### the new start of the SList
Discription:
Inserts a new element into the list at the given position.
If this is negative, or is larger than the number 
 *     of elements in the list, the new element is added on
 *     to the end of the list.
 *-------------------------------------------------------------------------*/
STSList*  st_slist_insert_sorted(STSList *list,
		stpointer			data,
		STCompareFunc		func)
{
	return st_slist_insert_sorted_real (list, data, (STFunc) func, NULL);
}

STSList*  st_slist_insert_sorted_with_data (STSList *list,
		stpointer          data,
		STCompareDataFunc  func,
		stpointer          user_data)
{
	return st_slist_insert_sorted_real (list, data, (STFunc) func, user_data);
}

/*-------------------------------------------------------------------------*
Function:	st_slist_insert
Created By:   è´©stjq
Created Date: è´?011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
stpointer data				### the data for the new element
stint position				### the position to insert the element. 
Returns:
STSList						### the new start of the SList
Discription:
Inserts a new element into the list at the given position.
If this is negative, or is larger than the number 
 *     of elements in the list, the new element is added on
 *     to the end of the list.
 *-------------------------------------------------------------------------*/
STSList*  st_slist_insert(STSList *list, stpointer data, stint position)
{
	STSList* new_list = NULL ;
	STSList* prev_list = NULL ;
	STSList* temp_list = NULL ;

	if(0 > position)
		st_slist_append(list, data);
	else if(0 == position)
		st_slist_prepend(list, data);

	new_list = st_slist_alloc();
	new_list->data = data ;

	if(NULL == list)
	{
		new_list->next = NULL ;
		return new_list ;
	}

	prev_list = NULL ;
	temp_list = list ;

	// ÕÒµ½ËùÔÚÎ»ÖÃ
	while((position-- > 0) && temp_list)	
	{
		prev_list = temp_list ;
		temp_list = temp_list->next ;
	}
	// ½«new_list·Åµ½ºÏÊÊµÄÎ»ÖÃ
	if(NULL != prev_list)
	{
		new_list->next = prev_list->next ;
		prev_list->next = list ;
	}
	else
	{
		new_list->next = list ;
		list = new_list ;
	}

	return list ;
}


/*-------------------------------------------------------------------------*
Function:	st_slist_prepend
Created By:   è´©stjq
Created Date: è´?011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
stpointer data
Returns:
STSList
Discription:
append the data to the start of list
 *-------------------------------------------------------------------------*/
STSList*  st_slist_prepend(STSList *list, stpointer data)
{
	STSList *new_list = NULL ;

	new_list = (STSList *)st_slist_alloc();
	new_list->data = data ;
	new_list->next = list ;

	return new_list ;
}

/*-------------------------------------------------------------------------*
Function:	st_slist_append
Created By:   è´©stjq
Created Date: è´?011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list		
stpointer data
Returns:
STSList
Discription:
append the data to the end of list
 *-------------------------------------------------------------------------*/
STSList*  st_slist_append(STSList *list, stpointer data)
{
	STSList* new_list = NULL ;
	STSList* last = NULL ;

	new_list = (STSList*)st_slist_alloc();
	new_list->data = data ;
	new_list->next = NULL ;

	if(NULL != list)
	{
		last = st_slist_last (list);
		/* g_assert (last != NULL); */
		last->next = new_list;

		return list;	
	}
	else
	{
		return new_list ;
	}
}

STSList*  st_slist_merge_2_list(STSList	*head1, STSList	*head2)
{
	STSList *head,*tail,*p = head1,*q = head2,*s;

    if( NULL == p )
        return q;
    if( NULL == q )
        return p;

    tail = p;
    if( p->data > q->data) 
        tail = q;
    head = tail;

    while( NULL != p && NULL != q )
    {
        if(p->data <= q->data ) 
            //Èç¹ûpËùÖ¸ÔªËØ<qËùÖ¸ÔªËØ£¬ÄÇÃ´°ÑpËùÖ¸ÔªËØ£¬ÂÊÏÈÀ­ÈëºÏ²¢ºóµÄÁ´±íÖÐ£¬
            //p¸³¸øs£¬²¢´ÓpµÄÏÂÒ»¸öÔªËØp->next²éÕÒ¡£
            //Ö±µ½·¢ÏÖpËùÖ¸ ²»ÔÙ < q£¬¶øÊÇp > qÁË ¼´×ªÖÁÏÂÊö´úÂëµÄelse²¿·Ö¡£
        {
            s = p; 
            p = p->next;
        }
        else
        {
            s = q;
            q = q->next;
        }
        tail->next = s;
        tail = s;
    }

    if( NULL == p )
        p = q;
    s = p;
    tail->next = s;

    return head;	
}


STSList*  st_slist_recursive_merge_2_list(STSList	*head1, STSList	*head2)
{
	STSList *head = NULL ;
	
	if ( head1 == NULL )
		return head2 ;
	if ( head2 == NULL)
		return head1 ;
	
	if ( head1->data < head2->data )
	{
		head = head1 ;
		head->next = st_slist_recursive_merge_2_list(head1->next,head2);
	}
	else
	{
		head = head2 ;
		head->next = st_slist_recursive_merge_2_list(head1,head2->next);
	}
	return head ;	
}


/*-------------------------------------------------------------------------*
Function:	st_slist_free
Created By:   è´©stjq
Created Date: è´?011/08/06
Modified By:
Modified Date:
Parameters:
STSList *list								
Returns:
void
Discription:
free all the mem of list node
 *-------------------------------------------------------------------------*/
void st_slist_free(STSList *list)
{
	STSList *temp = NULL ;

	if(NULL != list)
	{
		do
		{
			temp = list ;
			list = list->next ;
			free(temp);
			temp = NULL ;
		}while(NULL != list);
	}	
}

/*-------------------------------------------------------------------------*
Function:	st_slist_alloc
Created By:   è´©stjq
Created Date: è´?011/08/06
Modified By:
Modified Date:
Parameters:
void								### the list which be dump
Returns:
void
Discription:
alloc the mem of list node
 *-------------------------------------------------------------------------*/
STSList *st_slist_alloc(void)
{
	return malloc(sizeof(STSList));
}

void st_dump_list(STSList *head)
{
	STSList *p;

	p = head;		// protect the head point
	if(head != NULL) /*Ö»Òª²»ÊÇ¿ÕÁ´±í£¬¾ÍÊä³öÁ´±íÖÐËùÓÐ½Úµã*/
	{
		printf("head is %o\n", (stuint)head); /*Êä³öÍ·Ö¸ÕëÖ¸ÏòµÄµØÖ·*/
		do 
		{ 
			printf("%o   %d   %o\n", (stuint)p, (stint)p->data, (stuint)p->next);
			p = p->next; /*ÒÆµ½ÏÂÒ»¸ö½Úµã*/
		}
		while (p != NULL);
	}
}


///////////////////////////sort list///////////////////////////////
/*-------------------------------------------------------------------------*
Function:	st_slist_direct_insert_sort
Created By:   ..stjq
Created Date: ..2011/08/06
Modified By:
Modified Date:
Parameters:
STSList* list
Returns:
STSList* list
Discription:
==========================
 ¹¦ÄÜ£ºÖ±½Ó²åÈëÅÅÐò(ÓÉÐ¡µ½´ó)
 ·µ»Ø£ºÖ¸ÏòÁ´±í±íÍ·µÄÖ¸Õë
==========================
Ö±½Ó²åÈëÅÅÐòµÄ»ù±¾Ë¼Ïë¾ÍÊÇ¼ÙÉèÁ´±íµÄÇ°Ãæn-1¸ö½ÚµãÊÇÒÑ¾­°´¼üÖµ
£¨¾ÍÊÇÓÃËüÅÅÐòµÄ×Ö¶Î£¬ÎÒÃÇÈ¡Ñ§ºÅnumÎª¼üÖµ£©ÅÅºÃÐòµÄ£¬¶ÔÓÚ½ÚµãnÔÚ
Õâ¸öÐòÁÐÖÐÕÒ²åÈëÎ»ÖÃ£¬Ê¹µÃn²åÈëºóÐÂÐòÁÐÈÔÈ»ÓÐÐò¡£°´ÕÕÕâÖÖË¼Ïë£¬ÒÀ´Î
¶ÔÁ´±í´ÓÍ·µ½Î²Ö´ÐÐÒ»±é£¬¾Í¿ÉÒÔÊ¹ÎÞÐòÁ´±í±äÎªÓÐÐòÁ´±í¡£ 

µ¥ÏòÁ´±íµÄÖ±½Ó²åÈëÅÅÐòÍ¼Ê¾£º
---->[1]---->[3]---->[2]...---->[n]---->[NULL]£¨Ô­Á´±í£©
head   1->next  3->next  2->next   n->next

---->[1]---->[NULL]£¨´ÓÔ­Á´±íÖÐÈ¡µÚ1¸ö½Úµã×÷ÎªÖ»ÓÐÒ»¸ö½ÚµãµÄÓÐÐòÁ´±í£©
head
Í¼11

---->[3]---->[2]...---->[n]---->[NULL]£¨Ô­Á´±íÊ£ÏÂÓÃÓÚÖ±½Ó²åÈëÅÅÐòµÄ½Úµã£©
first   3->next  2->next   n->next
Í¼12

---->[1]---->[2]---->[3]...---->[n]---->[NULL]£¨ÅÅÐòºóÁ´±í£©
head   1->next  2->next  3->next   n->next

Í¼13£ºÓÐN¸ö½ÚµãµÄÁ´±íÖ±½Ó²åÈëÅÅÐò

1¡¢ÏÈÔÚÔ­Á´±íÖÐÒÔµÚÒ»¸ö½ÚµãÎªÒ»¸öÓÐÐòÁ´±í£¬ÆäÓà½ÚµãÎª´ý¶¨½Úµã¡£
2¡¢´ÓÍ¼12Á´±íÖÐÈ¡½Úµã£¬µ½Í¼11Á´±íÖÐ¶¨Î»²åÈë¡£
3¡¢ÉÏÃæÍ¼Ê¾ËäËµ»­ÁËÁ½ÌõÁ´±í£¬ÆäÊµÖ»ÓÐÒ»ÌõÁ´±í¡£ÔÚÅÅÐòÖÐ£¬ÊµÖÊÖ»Ôö¼ÓÁËÒ»¸ö
ÓÃÓÚÖ¸ÏòÊ£ÏÂÐèÒªÅÅÐò½ÚµãµÄÍ·Ö¸Õëfirst°ÕÁË¡£
ÕâÒ»µãÇë¶ÁÕßÎñ±Ø¸ãÇå³þ£¬Òª²»È»¾Í¿ÉÄÜÈÏÎªËüºÍÉÏÃæµÄÑ¡ÔñÅÅÐò·¨Ò»ÑùÁË¡£
 *-------------------------------------------------------------------------*/
STSList* st_slist_direct_insert_sort(STSList* head)
{
	STSList *first ;		/*ÎªÔ­Á´±íÊ£ÏÂÓÃÓÚÖ±½Ó²åÈëÅÅÐòµÄ½ÚµãÍ·Ö¸Õë*/
	STSList *iNode ;		/*ÁÙÊ±Ö¸Õë±äÁ¿£º²åÈë½Úµã*/	
	STSList *p; 			/*ÁÙÊ±Ö¸Õë±äÁ¿p->next == q*/
	STSList *q; 			/*ÁÙÊ±Ö¸Õë±äÁ¿p->next == q*/

	first = head->next ;	/*Ô­Á´±íÊ£ÏÂÓÃÓÚÖ±½Ó²åÈëÅÅÐòµÄ½ÚµãÁ´±í£º¿É¸ù¾ÝÍ¼12À´Àí½â¡£*/
	head->next = NULL ;		/*Ö»º¬ÓÐÒ»¸ö½ÚµãµÄÁ´±íÐÂµÄÓÐÐòÁ´±í£º¿É¸ù¾ÝÍ¼11À´Àí½â¡£*/

	while(NULL != first)	/*±éÀúÊ£ÏÂÎÞÐòµÄÁ´±í*/
	{
		/* ´ÎforÑ­»·²éÕÒÉèµ±µÄ²åÈëÎ»ÖÃ£¬±£´æÔÚpqÖ¸ÕëÉÏ */
		/*
		 * ÓÐÈýÖÖÇé¿ö:(1)²åÍ·;(2)²åÖÐ¼ä;(3)²åÎ²°Í
		 * 
		 */
		for(iNode = first, q = head ; (NULL != q) && (q->data < iNode->data) ; p = q, q = q->next);

		/*ÍË³öforÑ­»·£¬¾ÍÊÇÕÒµ½ÁË²åÈëµÄÎ»ÖÃ*/
		/*×¢Òâ£º°´µÀÀíÀ´Ëµ£¬Õâ¾ä»°¿ÉÒÔ·Åµ½ÏÂÃæ×¢ÊÍÁËµÄÄÇ¸öÎ»ÖÃÒ²Ó¦¸Ã¶ÔµÄ£¬µ«ÊÇ¾ÍÊÇ²»ÄÜ¡£Ô­Òò£ºÄãÈôÀí½âÁËÉÏÃæµÄµÚ3Ìõ£¬¾ÍÖªµÀÁË¡£*/
		first = first->next ;	/*ÎÞÐòÁ´±íÖÐµÄ½ÚµãÀë¿ª£¬ÒÔ±ãËü²åÈëµ½ÓÐÐòÁ´±íÖÐ¡£²¢Éú³ÉÐÂµÄ´ýÅÅÐòÁ´±í*/ 

		if(q == head)			/*²åÔÚµÚÒ»¸ö½ÚµãÖ®Ç°*/
		{
			head = iNode ;
		}
		else					/* ²åÖÐ¼ä»òÕß²åÎ²°Í£¬´ËÊ±pÎª´ý²éÎ»ÖÃµÄÉÏ¸ö½Úµã£¬qÎªÏÂ¸ö½Úµã£¬»òÕßÎªNULL */
		{
			p->next = iNode ;
		}
		iNode->next = q ;		/* Íê³É½ÚµãµÄ²åÈë£¬Éú³ÉÐÂµÄÅÅÐòÁÐ±í */ 
		/*first = first->next;*/
	}

	return head ;
}


/*-------------------------------------------------------------------------*
Function:	st_slist_select_sort
Created By:   ..stjq
Created Date: ..2011/08/06
Modified By:
Modified Date:
Parameters:
STSList* list
Returns:
STSList* list
Discription:
==========================
 ¹¦ÄÜ£ºÑ¡ÔñÅÅÐò(ÓÉÐ¡µ½´ó)
 ·µ»Ø£ºÖ¸ÏòÁ´±í±íÍ·µÄÖ¸Õë
==========================
Ñ¡ÔñÅÅÐòµÄ»ù±¾Ë¼Ïë¾ÍÊÇ·´¸´´Ó»¹Î´ÅÅºÃÐòµÄÄÇÐ©½ÚµãÖÐ£¬
 Ñ¡³ö¼üÖµ£¨¾ÍÊÇÓÃËüÅÅÐòµÄ×Ö¶Î£¬ÎÒÃÇÈ¡Ñ§ºÅnumÎª¼üÖµ£©×îÐ¡µÄ½Úµã£¬
 ÒÀ´ÎÖØÐÂ×éºÏ³ÉÒ»¸öÁ´±í¡£

 ÎÒÈÏÎªÐ´Á´±íÕâÀà³ÌÐò£¬¹Ø¼üÊÇÀí½â£º
 head´æ´¢µÄÊÇµÚÒ»¸ö½ÚµãµÄµØÖ·£¬head->next´æ´¢µÄÊÇµÚ¶þ¸ö½ÚµãµÄµØÖ·£»
 ÈÎÒâÒ»¸ö½ÚµãpµÄµØÖ·£¬Ö»ÄÜÍ¨¹ýËüÇ°Ò»¸ö½ÚµãµÄnextÀ´ÇóµÃ¡£

µ¥ÏòÁ´±íµÄÑ¡ÔñÅÅÐòÍ¼Ê¾£º
---->[1]---->[3]---->[2]...---->[n]---->[NULL]£¨Ô­Á´±í£©
head   1->next  3->next  2->next   n->next

---->[NULL]£¨¿ÕÁ´±í£©
first
tail

---->[1]---->[2]---->[3]...---->[n]---->[NULL]£¨ÅÅÐòºóÁ´±í£©
first   1->next  2->next  3->next   tail->next

Í¼10£ºÓÐN¸ö½ÚµãµÄÁ´±íÑ¡ÔñÅÅÐò

1¡¢ÏÈÔÚÔ­Á´±íÖÐÕÒ×îÐ¡µÄ£¬ÕÒµ½Ò»¸öºó¾Í°ÑËü·Åµ½ÁíÒ»¸ö¿ÕµÄÁ´±íÖÐ£»
2¡¢¿ÕÁ´±íÖÐ°²·ÅµÚÒ»¸ö½øÀ´µÄ½Úµã£¬²úÉúÒ»¸öÓÐÐòÁ´±í,²¢ÇÒÈÃËüÔÚÔ­Á´±íÖÐ·ÖÀë³öÀ´£¨´ËÊ±Òª×¢ÒâÔ­Á´±íÖÐ³öÀ´µÄÊÇµÚÒ»¸ö½Úµã»¹ÊÇÖÐ¼äÆäËü½Úµã£©£»
3¡¢¼ÌÐøÔÚÔ­Á´±íÖÐÕÒÏÂÒ»¸ö×îÐ¡µÄ£¬ÕÒµ½ºó°ÑËü·ÅÈëÓÐÐòÁ´±íµÄÎ²Ö¸ÕëµÄnext,È»ºóËü±ä³ÉÆäÎ²Ö¸Õë
 *-------------------------------------------------------------------------*/
STSList* st_slist_select_sort(STSList* head)
{
	STSList *first;	/*ÅÅÁÐºóÐÂÓÐÐòÁ´µÄ±íÍ·Ö¸Õë*/
	STSList *tail; 	/*ÅÅÁÐºóÐÂÓÐÐòÁ´µÄ±íÎ²Ö¸Õë*/ 
	STSList *p_min; /*±£Áô¼üÖµ¸üÐ¡µÄ½ÚµãµÄÇ°Çý½ÚµãµÄÖ¸Õë*/
	STSList *min; 	/*´æ´¢×îÐ¡½Úµã*/ 
	STSList *p; 	/*µ±Ç°ÁÙÊ±±È½ÏµÄ½Úµã*/

	first = NULL ;	/* ³õÊ¼»¯ÐÂÓÐÐòÁ´±íÎª¿Õ */

	while(NULL != head)
	{
		/*×¢Òâ£ºÕâÀïforÓï¾ä¾ÍÊÇÌåÏÖÑ¡ÔñÅÅÐòË¼ÏëµÄµØ·½*/
		/* Ã¿´Î±È½Ï¶¼±ØÐë°ÑÊ£ÓàµÄ´ýÅÅÐòÁ´±íÉ¨ÃèÒ»±é£¬ËùÒÔ±È½Ï´ÎÊýÎª((n-1)*n)/2 */
		for(p=head, min=head ; p->next != NULL ; p=p->next)	/*Ñ­»·±éÀúÁ´±íÖÐµÄ½Úµã£¬ÕÒ³ö´ËÊ±×îÐ¡µÄ½Úµã¡£*/
		{
			if(p->next->data < min->data)					/*ÕÒµ½Ò»¸ö±Èµ±Ç°minÐ¡µÄ½Úµã¡£*/
			{
				p_min = p ;									/*±£´æÕÒµ½½ÚµãµÄÇ°Çý½Úµã£ºÏÔÈ»p->nextµÄÇ°Çý½ÚµãÊÇp¡£*/
				min = p->next ;								/*±£´æ¼üÖµ¸üÐ¡µÄ½Úµã¡£*/
			}	
		}
		/*ÉÏÃæforÓï¾ä½áÊøºó£¬¾ÍÒª×öÁ½¼þÊÂ£»Ò»ÊÇ°ÑËü·ÅÈëÐÂÓÐÐòÁ´±íÖÐ£»¶þÊÇ¸ù¾ÝÏàÓ¦µÄÌõ¼þÅÐ¶Ï£¬°²ÅÅËüÀë¿ªÔ­À´µÄÁ´±í¡£*/
		/*µÚÒ»¼þÊÂÌí¼Ó×îÐ¡µÄ½Úµãµ½ÐÂÓÐÐòÁ´±í*/
		if(NULL == first)
		{
			first = min ;				/*µÚÒ»´ÎÕÒµ½¼üÖµ×îÐ¡µÄ½Úµã¡£*/
			tail = min ;				/*×¢Òâ£ºÎ²Ö¸ÕëÈÃËüÖ¸Ïò×îºóµÄÒ»¸ö½Úµã¡£*/
		}	
		else							/*ÓÐÐòÁ´±íÖÐÒÑ¾­ÓÐ½Úµã*/
		{
			tail->next = min ;			/* °ÑÐÂµÄ×îÐ¡½ÚµãÌí¼Óµ½ÓÐÐòÁ´µÄÎ²²¿ */
			tail = min ;				/* ¸üÐÂÓÐÐòÁ´µÄÎ²½ÚµãÖ¸Õë */
		}

		/*µÚ¶þ¼þÊÂÉ¾³ýÔ­Á´±í½Úµã*/
		if(min == head)					/*Èç¹ûÕÒµ½µÄ×îÐ¡½Úµã¾ÍÊÇµÚÒ»¸ö½Úµã*/
		{
			head = head->next ;			/* Ö±½Ó¸üÐÂÎÞÐòÁ´µÄÍ·Ö¸ÕëÎªhead->next */
		}
		else							/*Èç¹û²»ÊÇµÚÒ»¸ö½Úµã*/
		{
			p_min->next = min->next ;	/*Ç°´Î×îÐ¡½ÚµãµÄnextÖ¸Ïòµ±Ç°minµÄnext,ÕâÑù¾ÍÈÃminÀë¿ªÁËÔ­Á´±í¡£*/
		}
	}

	/*Ñ­»·½áÊøµÃµ½ÓÐÐòÁ´±ífirst*/
	if(NULL != first)
		tail->next = NULL ;				/*µ¥ÏòÁ´±íµÄ×îºóÒ»¸ö½ÚµãµÄnextÓ¦¸ÃÖ¸ÏòNULL*/ 

	head = first ;

	return head ;
}

static void my_swap(stint **a,stint **b)  
{  
    stint temp; 
    temp=*a;  
    *a=*b;  
    *b=temp;  
}  

STSList* st_slist_quick_sort(STSList* phead, STSList *pend)
{
	STSList *pslow=phead;  
    STSList *pfast=phead->next;  
    STSList *ptemp=phead;  

    if(phead==NULL || pend==NULL)  
        return ;  
    if(phead==pend)  
        return ;  
    
    while(pfast)  
    {  
        if(pfast->data<phead->data)					//Ã¿´Î¶¼Ñ¡Ôñ´ýÅÅÐòÁ´±íµÄÍ·½áµã×÷Îª»®·ÖµÄ»ù×¼  
        {  
            ptemp=pslow;							//ptempÊ¼ÖÕÎªpslowµÄÇ°Çý½áµã  
            pslow=pslow->next;  
			//fprintf(stderr, "pslow->data %d, pfast->data %d\n", pslow->data, pfast->data);
            my_swap(&pslow->data,&pfast->data);		//pslowÖ¸ÕëÖ¸Ïò±È»ù×¼Ð¡µÄ½áµã×é³ÉµÄÁ´±í  
            //fprintf(stderr, "pslow->data %d, pfast->data %d\n", pslow->data, pfast->data);
        }  
        pfast=pfast->next;  
    }  
  
    my_swap(&pslow->data,&phead->data);				//´ËÊ±pslowÖ¸ÕëÖ¸Ïò±È»ù×¼Ð¡µÄ½áµã×é³ÉµÄÁ´±íµÄ×îºóÒ»¸ö½áµã£¬Ò²¾ÍÊÇ»ù×¼µÄÎ»ÖÃ£¬ËùÒÔÒªÓë»ù×¼£¨head½áµã£©½»»»  
    
    st_slist_quick_sort(phead,ptemp);				//ptempÎª×óÓÒÁ½²¿·Ö·Ö¸îµã£¨»ù×¼£©µÄÇ°Ò»¸ö½áµã  
    st_slist_quick_sort(pslow->next,pend);			//ÓÒ²¿·ÖÊÇ±È»ù×¼´óµÄ½áµã×é³ÉµÄÁ´±í 	

	return phead ;
}


void st_slist_quick_sort2(STSList **head, STSList *end)  
{
    STSList *right;     
    STSList **left_walk, **right_walk;     
    STSList *pivot, *old;     
    stint count, left_count, right_count;     
    if (*head == end)  
        return;  
	
    do {     
        pivot = *head;
        left_walk = head;
        right_walk = &right;     
        left_count = right_count = 0;     
        //È¡µÚÒ»¸ö½Úµã×÷Îª±È½ÏµÄ»ù×¼£¬Ð¡ÓÚ»ù×¼µÄÔÚ×óÃæµÄ×ÓÁ´±íÖÐ£¬     
        //´óÓÚ»ù×¼µÄÔÚÓÒ±ßµÄ×ÓÁ´±íÖÐ     
        for (old = (*head)->next; old != end; old = old->next)  
        {     
            if (old->data < pivot->data)  
            {      
            	//Ð¡ÓÚ»ù×¼,¼ÓÈëµ½×óÃæµÄ×ÓÁ´±í,¼ÌÐø±È½Ï     
                ++left_count;     
                *left_walk = old;            //°Ñ¸Ã½Úµã¼ÓÈëµ½×ó±ßµÄÁ´±íÖÐ£¬     
                left_walk = &(old->next);     
            }  
            else  
            {                         //´óÓÚ»ù×¼,¼ÓÈëµ½ÓÒ±ßµÄ×ÓÁ´±í£¬¼ÌÐø±È½Ï     
                ++right_count;     
                *right_walk = old;                
                right_walk = &(old->next);     
            }     
        }     
        //ºÏ²¢Á´±í     
        *right_walk = end;       //½áÊøÓÒÁ´±í     
        *left_walk = pivot;      //°Ñ»ù×¼ÖÃÓÚÕýÈ·µÄÎ»ÖÃÉÏ     
        pivot->next = right;     //°ÑÁ´±íºÏ²¢     
        //¶Ô½ÏÐ¡µÄ×ÓÁ´±í½øÐÐ¿ìÅÅÐò£¬½Ï´óµÄ×ÓÁ´±í½øÐÐµü´úÅÅÐò¡£     
        if(left_walk > right_walk)  
        {  
            st_slist_quick_sort2(&(pivot->next), end);     
            end = pivot;     
            count = left_count;     
        }  
        else  
        {     
            st_slist_quick_sort2(head, pivot);     
            head = &(pivot->next);     
            count = right_count;     
        }     
    }  
    while (count > 1);      	
}




/*»ñÈ¡Á´±íÖÐµÄ½ÚµãÊý*/
static stint getNodeNum(STSList* h)
{
	int n=0;
	while(h)
	{
		n++;
		h=h->next;
	}
	return n;
}

 

/*°ÑÒ»¸öÖ¸ÕëÒÆ¶¯n²½*/
static void move(STSList** h,stint n)
{
	stint i;
	for(i=0;i<n;i++)
	{
		*h=(*h)->next;
	}
}

void st_slist_shell_sort(STSList* list)
{
	stint i=0;
	stint flag=0;		/*±ê¼ÇÒ»´Î¿ìËÙ²åÈëµü´úÊÇ·ñ½áÊø*/
	STSList* h1;		/*h1ÓÃÀ´´ÓÍ·¿ªÊ¼±éÀúÑ°ÕÒ²åÈë½Úµã*/
	STSList* h2;		/*h2ÓÃÀ´Ö¸ÏòÐèÒª²åÈëµÄ½áµã*/
	STSList* h3;		/*h3ÓÃÀ´Ö¸Ïòh2µÄÇ°Ò»¸ö½áµã*/
	stint n=0;			/*½ÚµãÊý*/
	stint t;			/*²½½øÖµ*/
	
	n=getNodeNum(list);	/*½ÚµãÊý*/

	for(t=n/2;t>0;t=t/2)/*Ï£¶ûµü´ú£¬Ã¿´ÎËõÐ¡²½½øÖµ*/
	{
		h2=h3=list;		/*Ã¿´ÎÏ£¶ûµü´ú£¬³õÊ¼»¯h2ºÍh3µÄÎ»ÖÃ*/
		move(&h3,t-1);
		move(&h2,t);	/*ÒÆ¶¯t²½*/

		while(h2)		/*²åÈëÅÅÐò*/
		{
			h1=list;	/*³õÊ¼»¯h1µÄÎ»ÖÃ*/
			flag=0;		/*flagÖÃ0*/
			while(flag==0)
			{
				if((h1->next->data) > (h2->data))/*Èç¹ûÕÒµ½£¬¼´°Ñh2ËùÖ¸ÏòµÄ½áµã²åµ½h1ºóÃæ£¬È»ºóÌø³öÑ­»·*/
				{
					h3->next=h2->next;
					h2->next=h1->next;
					h1->next=h2;
					h2=h3->next;/*h2ËùÖ¸½ÚµãÒÑ¾­ÒÆµ½Ç°Ãæ£¬h2ÒªÏòºóÒÆ¶¯*/
					break; /*±ðÍüÁË´Ë´¦µÄbreak*/
				}
				/*ÒÆ¶¯h1*/
				for(i=0 ; i<t ; i++)
				{
					h1=h1->next;
					if((h1==h2)||(h1==NULL))
					{
						flag=1;/*h1ÒÆµ½ÁËh2*/
						break;/*ÂíÉÏÍ£Ö¹ÒÆ¶¯£¬·ÀÖ¹Ö¸ÕëÔ½½ç*/
					}
				}
			}

			if((flag==1)&&(h2!=NULL))/*Ö»ÔÚh2ËùÖ¸½áµã²»ÐèÒªÇ°²åÊ±£¬ÒÆ¶¯h2ºÍh3*/
			{
				h2=h2->next;
				h3=h3->next;
			}
		}
	}	
}


/*-------------------------------------------------------------------------*
Function:	st_slist_bubble_sort
Created By:   ..stjq
Created Date: ..2011/08/06
Modified By:
Modified Date:
Parameters:
STSList* list
Returns:
STSList* list
Discription:
==========================
 ¹¦ÄÜ£ºÃ°ÅÝÅÅÐò(ÓÉÐ¡µ½´ó)
 ·µ»Ø£ºÖ¸ÏòÁ´±í±íÍ·µÄÖ¸Õë
==========================
Ö±½Ó²åÈëÅÅÐòµÄ»ù±¾Ë¼Ïë¾ÍÊÇ¶Ôµ±Ç°»¹Î´ÅÅºÃÐòµÄ·¶Î§ÄÚµÄÈ«²¿½Úµã£¬
 ×ÔÉÏ¶øÏÂ¶ÔÏàÁÚµÄÁ½¸ö½ÚµãÒÀ´Î½øÐÐ±È½ÏºÍµ÷Õû£¬ÈÃ¼üÖµ£¨¾ÍÊÇÓÃËüÅÅ
 ÐòµÄ×Ö¶Î£¬ÎÒÃÇÈ¡Ñ§ºÅnumÎª¼üÖµ£©½Ï´óµÄ½ÚµãÍùÏÂ³Á£¬¼üÖµ½ÏÐ¡µÄÍù
 ÉÏÃ°¡£¼´£ºÃ¿µ±Á½ÏàÁÚµÄ½Úµã±È½Ïºó·¢ÏÖËüÃÇµÄÅÅÐòÓëÅÅÐòÒªÇóÏà·´Ê±£¬
 ¾Í½«ËüÃÇ»¥»»¡£

 
µ¥ÏòÁ´±íµÄÃ°ÅÝÅÅÐòÍ¼Ê¾£º
---->[1]---->[3]---->[2]...---->[n]---->[NULL]£¨Ô­Á´±í£©
head   1->next  3->next  2->next   n->next 

---->[1]---->[2]---->[3]...---->[n]---->[NULL]£¨ÅÅÐòºóÁ´±í£©
head   1->next  2->next  3->next   n->next

Í¼14£ºÓÐN¸ö½ÚµãµÄÁ´±íÃ°ÅÝÅÅÐò

ÈÎÒâÁ½¸öÏàÁÚ½Úµãp¡¢qÎ»ÖÃ»¥»»Í¼Ê¾:
¼ÙÉèp1->nextÖ¸Ïòp£¬ÄÇÃ´ÏÔÈ»p1->next->next¾ÍÖ¸Ïòq,
p1->next->next->next¾ÍÖ¸ÏòqµÄºó¼Ì½Úµã£¬ÎÒÃÇÓÃp2±£´æ
p1->next->nextÖ¸Õë¡£¼´£ºp2=p1->next->next£¬ÔòÓÐ£º
[  ]---->[p]---------->[q]---->[  ]£¨ÅÅÐòÇ°£©
  p1->next  p1->next->next  p2->next
Í¼15

[  ]---->[q]---------->[p]---->[  ]£¨ÅÅÐòºó£©

Í¼16

1¡¢ÅÅÐòºóq½ÚµãÖ¸Ïòp½Úµã£¬ÔÚµ÷ÕûÖ¸ÏòÖ®Ç°£¬ÎÒÃÇÒª±£´æÔ­pµÄÖ¸Ïò½ÚµãµØÖ·£¬¼´£ºp2=p1->next->next£»
2¡¢Ë³×ÅÕâÒ»²½Ò»²½ÍùÏÂÍÆ,ÅÅÐòºóÍ¼16ÖÐp1->next->nextÒªÖ¸µÄÊÇp2->next,ËùÒÔp1->next->next=p2->next;
3¡¢ÔÚÍ¼15ÖÐp2->nextÔ­ÊÇq·¢³öÀ´µÄÖ¸Ïò£¬ÅÅÐòºóÍ¼16ÖÐqµÄÖ¸ÏòÒª±äÎªÖ¸ÏòpµÄ£¬¶øÔ­À´p1->nextÊÇÖ¸ÏòpµÄ£¬ËùÒÔp2->next=p1->next;
4¡¢ÔÚÍ¼15ÖÐp1->nextÔ­ÊÇÖ¸ÏòpµÄ£¬ÅÅÐòºóÍ¼16ÖÐp1->nextÒªÖ¸Ïòq,Ô­À´p1->next->next£¨¼´p2)ÊÇÖ¸ÏòqµÄ£¬ËùÒÔp1->next=p2;
5¡¢ÖÁ´Ë£¬ÎÒÃÇÍê³ÉÁËÏàÁÚÁ½½ÚµãµÄË³Ðò½»»»¡£
6¡¢ÏÂÃæµÄ³ÌÐòÃèÊö¸Ä½øÁËÒ»µã¾ÍÊÇ¼ÇÂ¼ÁËÃ¿´Î×îºóÒ»´Î½ÚµãÏÂ³ÁµÄÎ»ÖÃ£¬ÕâÑùÎÒÃÇ²»±ØÃ¿´Î¶¼´ÓÍ·µ½Î²µÄÉ¨Ãè£¬Ö»ÐèÒªÉ¨Ãèµ½¼ÇÂ¼µãÎªÖ¹¡£
   ÒòÎªºóÃæµÄ¶¼ÒÑ¾­ÊÇÅÅºÃÐòµÄÁË¡£
 *-------------------------------------------------------------------------*/
STSList* st_slist_bubble_sort(STSList* head)
{
	STSList *endpt; 	/*¿ØÖÆÑ­»·±È½Ï*/
	STSList *p; 		/*ÁÙÊ±Ö¸Õë±äÁ¿*/
	STSList *p1; 
	STSList *p2;

	p1 = (STSList *)malloc(sizeof(STSList));
 	p1->next = head;	/*×¢ÒâÀí½â£ºÎÒÃÇÔö¼ÓÒ»¸ö½Úµã£¬·ÅÔÚµÚÒ»¸ö½ÚµãµÄÇ°Ãæ£¬Ö÷ÒªÊÇÎªÁË±ãÓÚ±È½Ï¡£ÒòÎªµÚÒ»¸ö½ÚµãÃ»ÓÐÇ°Çý£¬ÎÒÃÇ²»ÄÜ½»»»µØÖ·¡£*/
 	head = p1;			/*ÈÃheadÖ¸Ïòp1½Úµã£¬ÅÅÐòÍê³Éºó£¬ÎÒÃÇÔÙ°Ñp1½ÚµãÊÍ·Åµô*/

	for (endpt=NULL; endpt!=head; endpt=p) /*½áºÏµÚ6µãÀí½â*/
	{
		for (p=p1=head; p1->next->next!=endpt; p1=p1->next)
		{
			if (p1->next->data > p1->next->next->data) /*Èç¹ûÇ°ÃæµÄ½Úµã¼üÖµ±ÈºóÃæ½ÚµãµÄ¼üÖµ´ó£¬Ôò½»»»*/
			{
				p2 = p1->next->next; 		/*½áºÏµÚ1µãÀí½â*/	/* ±£´æºóÇýµÄËùÓÐ½Úµã */
				p1->next->next = p2->next;	/*½áºÏµÚ2µãÀí½â*/	/* °ÑºóÇý½ÚµãÌáÇ°Ò»Î» */
				p2->next = p1->next; 		/*½áºÏµÚ3µãÀí½â*/	/* °Ñ½»»»ºÃµÄ½Úµã´æ·ÅÔÚp2 */
				p1->next = p2; 				/*½áºÏµÚ4µãÀí½â*/	/* °Ñ½»»»ºÃµÄ½Úµã´æ·ÅÔÚp1 */
				p = p1->next->next; 		/*½áºÏµÚ6µãÀí½â*/	/* ¼ÇÂ¼ÁËÃ¿´Î×îºóÒ»´Î½ÚµãÏÂ³ÁµÄÎ»ÖÃ */
			}
		}
	}

	p1 = head; 			/*°Ñp1µÄÐÅÏ¢È¥µô*/
	head = head->next; 	/*ÈÃheadÖ¸ÏòÅÅÐòºóµÄµÚÒ»¸ö½Úµã*/
	free(p1); 			/*ÊÍ·Åp1*/
	p1 = NULL; 			/*p1ÖÃÎªNULL£¬±£Ö¤²»²úÉú¡°Ò°Ö¸Õë¡±£¬¼´µØÖ·²»È·¶¨µÄÖ¸Õë±äÁ¿*/

	return head;
}


STSList** DistributeL(STSList* p, int keyNum, STSList ** pa, stint NUM) 	//½øÐÐÊý¾ÝµÄ·ÖÅä
{
	stint arr[10]= {0};	/*	¼ÇÂ¼Í¬Ò»¸öÎ»ÊýÏàÍ¬ÊýµÄ¸öÊý	*/
	stint k;

	while(p)
	{
		k = (stint)p->data/keyNum%10;

		if(NULL == pa[k])
		{
			pa[k] = (STSList*)malloc(sizeof(STSList)*NUM);
			pa[k][arr[k]] = *p;
			pa[k][arr[k]].next = NULL;
			++arr[k];
		}
		else
		{
			pa[k][arr[k]] = *p;
			pa[k][arr[k]].next = NULL;
			pa[k][arr[k]-1].next = &pa[k][arr[k]];
			++arr[k];
		}
		p = p->next;
	}

	return pa;

}

STSList* CollectL(STSList* p, STSList ** pa, stint NUM)  		//½øÐÐÊý¾ÝµÄÊÕ¼¯
{
	stint count;
	stint i = 0;
	STSList* pc;		/*	´æ´¢pa[count]µÄ³õÊ¼Öµ£¬ÔÚÊÍ·Å¿Õ¼äÊ±Ê¹ÓÃ	*/
	STSList* pp = p;	/*	´æ´¢pµÄ³õÊ¼Öµ£¬·µ»ØÖµÊ±Ê¹ÓÃ	*/

	for(count = 0; count < NUM; ++count)
	{
		pc = pa[count];

		while(NULL != pa[count])
		{
			p[i] = *pa[count];
			pa[count] = pa[count]->next;
			if((NUM-1) == i)
			{
				p[i].next = NULL;
			}
			else
			{
				p[i].next = &p[i+1];
			}

			++i;

		} 

		pa[count] = pc;

		if(NULL != pa[count])
			free(pa[count]);

	}

	return pp;

}


STSList* st_slist_radix_sort(STSList* list, stint radix)
{
	stint key = 1;
	stint i;
	stint j;
	STSList* h[10] = {0};
	stint NUM ;

	NUM = getNodeNum(list);			
	for(i = 0; i < radix; ++i, key *= 10)
	{
		DistributeL(list, key, h, NUM);
		
		list = CollectL((STSList*)list, h, NUM);
		
		for(j = 0; j < NUM; ++j)
			h[j] = NULL;
		
		//printf("after sort\n");
		//OutputLink(p);
	}	

	return list ;	
}


