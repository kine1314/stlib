1.时间频度
　　一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。
2.计算方法
　　1. 一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f（n），因此，算法的时间复杂度记做：T（n）=O（f（n）） 　　分析：随着模块n的增大，算法执行的时间的增长率和f（n）的增长率成正比，所以f（n）越小，算法的时间复杂度越低，算法的效率越高。 　　2. 在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出T（n）的同数量级（它的同数量级有以下：1，Log2n ，n ，nLog2n ，n的平方，n的三次方，2的n次方，n！），找出后，f（n）=该数量级，若T(n)/f(n)求极限可得到一常数c，则时间复杂度T（n）=O（f（n）） 　　例：算法： 　　
for（i=1;i<=n;++i） 　　
{ 　　
	for(j=1;j<=n;++j) 　　
	{ 　　
		c[ i ][ j ]=0; //该步骤属于基本操作 执行次数：n的平方 次 　　
		for(k=1;k<=n;++k) 　　
			c[ i ][ j ]+=a[ i ][ k ]*b[ k ][ j ]; //该步骤属于基本操作 执行次数：n的三次方 次 　　
	} 　　
} 　　
则有 T（n）= n的平方+n的三次方，根据上面括号里的同数量级，我们可以确定 n的三次方 为T（n）的同数量级 　　则有f（n）= n的三次方，然后根据T（n）/f（n）求极限可得到常数c 　　则该算法的 时间复杂度：T（n）=O（n的三次方）
3.分类
　　按数量级递增排列，常见的时间复杂度有： 　　常数阶O(1),对数阶O(log2n),线性阶O(n), 　　线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),...， 　　k次方阶O(nk), 指数阶O(2n) 。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

//----------------
二分法的基本思想如下：
假设数据是按升序排序的，对于给定值x，从序列的中间位置开始比较，如果当前位置值等于x，则查找成功；若x小于当前位置值，则在数列的前半段中查找；若x大于当前位置值则在数列的后半段中继续查找，直到找到为止。
由于是数组是预先排序好的，所以可以采用折半查询的方式，每次抛掉待查询部分的一半
这样，长度为N的数组，只需要log2N次查询即可，2是对数的底。
例如，长度为7的数组，最多只需要3次就可以找到
O(log2n)只是表示是log2N同一数量级，因为有个取整的问题，而且也有可能在查询过程中就已经找到（也就是某个折半查询点正好是待查询数据），这样O(log2n)就是一个上限


//----------------
常见算法时间复杂度：
O(1): 表示算法的运行时间为常量
O(n): 表示该算法是线性算法
O(S2 n): 二分查找算法
O(n2 ): 对数组进行排序的各种简单算法，例如直接插入排序的算法。
O(n3 ): 做两个n阶矩阵的乘法运算
O(2n ): 求具有n个元素集合的所有子集的算法
O(n!): 求具有N个元素的全排列的算法
优<---------------------------<劣
O(1)<O(S2 n)<O(n)<O(n2 )<O(2n )
时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2 n)、线性阶O(n)、线性对数阶O(nlog2 n)、平方阶O(n2 )、立方阶O(n3 )、……k次方阶O(nk )、指数阶O(2n )。
  
时间复杂度 
算法分析 
同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。 

1、时间复杂度 
（1）时间频度 
一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 
（2）时间复杂度 
在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 
一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 
在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 
按数量级递增排列，常见的时间复杂度有： 
常数阶O(1),对数阶O(log2n),线性阶O(n), 
线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),...， 
k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 
2、空间复杂度 
与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作: 
S(n)=O(f(n)) 
我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模。
 
 
 
 
 1）时间频度 
一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 
（2）时间复杂度 
在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 
一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 
在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如 T(n)=n^2+3n+4与T(n)=4n^2+2n+1它们的频度不同，但时间复杂度相同，都为O(n^2)。 
按数量级递增排列，常见的时间复杂度有： 
常数阶O(1),对数阶O(log(2)n),线性阶O(n), 
线性对数阶O(nlog(2)n),平方阶O(n^2)，立方阶O(n^3),...， 
k次方阶O(n^k),指数阶O(2^n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 
（3）算法的时间复杂度 
若要比较不同的算法的时间效率，受限要确定一个度量标准，最直接的办法就是将计算法转化为程序，在计算机上运行，通过计算机内部的计时 
功能获得精确的时间，然后进行比较。但该方法受计算机的硬件、软件等因素的影响，会掩盖算法本身的优劣，所以一般采用事先分析估算的算法， 
即撇开计算机软硬件等因素，只考虑问题的规模（一般用用自然数n表示），认为一个特定的算法的时间复杂度，只采取于问题的规模，或者说它是 
问题的规模的函数。 
为了方便比较，通常的做法是，从算法选取一种对于所研究的问题（或算法模型）来说是基本运算的操作，以其重复执行的次数作为评价算法时间 
复杂度的标准。该基本操作多数情况下是由算法最深层环内的语句表示的，基本操作的执行次数实际上就是相应语句的执行次数。 
一般 T（n）=O(f(n)) 
O(1)<O(log2n)<O(n)<O(n log2 n)<O(n^2)<O(n^3)<O(2^n)所以要选择时间复杂度量级低的算法。 

时间复杂度　　1. 算法复杂度分为 时间复杂度和空间复杂度。 
　　作用： 时间复杂度是度量算法执行的时间长短；而空间复杂度是度量算法所需存储空间的大小。 
　　2. 一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f（n），因此，算法的时间复杂度记做：T（n）=O（f（n）） 
　　分析：随着模块n的增大，算法执行的时间的增长率和f（n）的增长率成正比，所以f（n）越小，算法的时间复杂度越低，算法的效率越高。 
　　3. 在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，在找出T（n）的同数量级（它的同数量级有以下：1，Log2n ，n ，nLog2n ，n的平方，n的三次方，2的n次方，n！），找出后，f（n）=该数量级，若T(n)/f(n)求极限可得到一常数c，则时间复杂度 T（n）=O（f（n）） 
　　例：算法： 
　　for（i=1;i<=n;++i） 
　　{ 
　　 for(j=1;j<=n;++j) 
　　{ 
　　c[ i ][ j ]=0; //该步骤属于基本操作 执行次数：n的平方 次 
　　for(k=1;k<=n;++k) 
　　c[ i ][ j ]+=a[ i ][ k ]*b[ k ][ j ]; //该步骤属于基本操作 执行次数：n的三次方 次 
　　} 
　　} 
　　则有 T（n）= n的平方+n的三次方，根据上面空号里的同数量级，我们可以确定 n的三次方 为T（n）的同数量级 
　　则有f（n）= n的三次方，然后根据T（n）/f（n）求极限可得到常数c 
　　则该算法的 时间复杂度：T（n）=O（n的三次方） 



定义：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。 
当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。 
我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立 f(n)=O(n^2)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。 
此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是最佳算法。 

“ 大O记法”：在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。 

这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。例如，一个低附加代价的O(n2)算法在n较小的情况下可能比一个高附加代价的 O(nlogn)算法运行得更快。当然，随着n足够大以后，具有较慢上升函数的算法必然工作得更快。 

O(1) 

Temp=i;i=j;j=temp;                    

以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 

O(n^2) 

2.1. 交换i和j的内容 
     sum=0；                 （一次） 
     for(i=1;i<=n;i++)       （n次 ） 
        for(j=1;j<=n;j++) （n^2次 ） 
         sum++；       （n^2次 ） 
解：T(n)=2n^2+n+1 =O(n^2) 

2.2.   
    for (i=1;i<n;i++) 
    { 
        y=y+1;         ①   
        for (j=0;j<=(2*n);j++)    
           x++;        ②      
    }         
解： 语句1的频度是n-1 
          语句2的频度是(n-1)*(2n+1)=2n^2-n-1 
          f(n)=2n^2-n-1+(n-1)=2n^2-2 
          该程序的时间复杂度T(n)=O(n^2).         

O(n)       
                                                      
2.3. 
    a=0; 
    b=1;                      ① 
    for (i=1;i<=n;i++) ② 
    {  
       s=a+b;　　　　③ 
       b=a;　　　　　④  
       a=s;　　　　　⑤ 
    } 
解： 语句1的频度：2,        
           语句2的频度： n,        
          语句3的频度： n-1,        
          语句4的频度：n-1,    
          语句5的频度：n-1,                                  
          T(n)=2+n+3(n-1)=4n-1=O(n). 
                                                                                                 
O(log2n ) 

2.4. 
     i=1;       ① 
    while (i<=n) 
       i=i*2; ② 
解： 语句1的频度是1,  
          设语句2的频度是f(n),   则：2^f(n)<=n;f(n)<=log2n    
          取最大值f(n)= log2n, 
          T(n)=O(log2n ) 

O(n^3) 

2.5. 
    for(i=0;i<n;i++) 
    {  
       for(j=0;j<i;j++)  
       { 
          for(k=0;k<j;k++) 
             x=x+2;  
       } 
    } 
解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3). 
                                  

我们还应该区分算法的最坏情况的行为和期望行为。如快速排序的最 坏情况运行时间是 O(n^2)，但期望时间是 O(nlogn)。通过每次都仔细地选择基准值，我们有可能把平方情况 (即O(n^2)情况)的概率减小到几乎等于 0。在实际中，精心实现的快速排序一般都能以 (O(nlogn)时间运行。 
下面是一些常用的记法： 


访问数组中的元素是常数时间操作，或说O(1)操作。一个算法如 果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。用strcmp比较两个具有n个字符的串需要O(n)时间。常规的矩阵乘算法是O(n^3)，因为算出每个元素都需要将n对 元素相乘并加到一起，所有元素的个数是n^2。 
指数时间算法通常来源于需要求出所有可能结果。例如，n个元 素的集合共有2n个子集,所以要求出所有子集的算法将是O(2n)的。指数算法一般说来是太复杂了，除非n的值非常小，因为，在 这个问题中增加一个元素就导致运行时间加倍。不幸的是，确实有许多问题 (如著名的“巡回售货员问题” )，到目前为止找到的算法都是指数的。如果我们真的遇到这种情况， 通常应该用寻找近似最佳结果的算法替代之。 

//-----------------
学习数据结构时，觉得时间复杂度计算很复杂，怎么也看不懂，差不多三年之后，还是不懂，马上就要找工作了，赶紧恶补一下吧：
首先了解一下几个概念。一个是时间复杂度，一个是渐近时间复杂度。前者是某个算法的时间耗费，它是该算法所求解问题规模n的函数，而后者是指当问题规模趋向无穷大时，该算法时间复杂度的数量级。
当我们评价一个算法的时间性能时，主要标准就是算法的渐近时间复杂度，因此，在算法分析时，往往对两者不予区分，经常是将渐近时间复杂度T(n)=O(f(n))简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。
此外，算法中语句的频度不仅与问题规模有关，还与输入实例中各元素的取值相关。但是我们总是考虑在最坏的情况下的时间复杂度。以保证算法的运行时间不会比它更长。
常见的时间复杂度，按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n^2)、立方阶O(n^3)、k次方阶O(n^k)、指数阶O(2^n)。
1. 大O表示法
定义

设一个程序的时间复杂度用一个函数 T(n) 来表示，对于一个查找算法，如下：

int seqsearch( int a[], const int n, const int x)
{
int i = 0;
for (; a[i] != x && i < n ; i++ );
if ( i == n) return -1;
else return i;
}
这个程序是将输入的数值顺序地与数组中地元素逐个比较，找出与之相等地元素。

在第一个元素就找到需要比较一次，在第二个元素找到需要比较2次，……　，在第n个元素找到需要比较n次。对于有n个元素的数组，如果每个元素被找到的概率相等，那么查找成功的平均比较次数为:

f(n) = 1/n (n + (n-1) + (n-2) + ... + 1) = (n+1)/2 = O(n)

这就是传说中的大O函数的原始定义。
用大O来表述 
要全面分析一个算法，需要考虑算法在最坏和最好的情况下的时间代价，和在平均情况下的时间代价。对于最坏情况，采用大O表示法的一般提法（注意，这里用的是“一般提法”）是：当且仅当存在正整数c和n0,使得 T(n) <= c*f(n)对于所有的n >= n0 都成立。则称该算法的渐进时间复杂度为T(n) = O(f(n))。这个应该是高等数学里面的第一章极限里面的知识。这里f(n) = (n+1)/2, 那么c * f(n)也就是一个一次函数。就是在图象上看就是如果这个函数在c*f(n)的下面，就是复杂度为T(n) = O(f(n))。
对于对数级，我们用大O记法记为O(log2N)就可以了。

规则
1） 加法规则
T(n,m) = T1(n) + T2(n) = O ( max (f(n), g(m) )
2) 乘法规则
T(n,m) = T1(n) * T2(m) = O (f(n) * g(m))
3)一个特例
在大O表示法里面有一个特例，如果T1(n) ＝ O?， c是一个与n无关的任意常数，T2(n) = O ( f(n) ) 则有
T(n) = T1(n) * T2(n) = O ( c*f(n) ) = O( f(n) ).

也就是说，在大O表示法中，任何非0正常数都属于同一数量级，记为O(1)。
4)一个经验规则
有如下复杂度关系
c < log2N < n < n * Log2N < n^2 < n^3 < 2^n < 3^n < n!
其中c是一个常量，如果一个算法的复杂度为c 、 log2N 、n 、 n*log2N ,那么这个算法时间效率比较高 ，如果是 2^n , 3^n ,n!,那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意.
1）基本知识点：没有循环的一段程序的复杂度是常数，一层循环的复杂度是O(n),两层循环的复杂度是O(n^2)? （我用^2表示平方，同理 ^3表示立方）；
2）二维矩阵的标准差，残差，信息熵，fft2,dwt2,dct2的时间复杂度: 标准差和残差可能O(n)，FFT2是O(nlog(n))，DWT2可能也是O(nlog(n))；信息熵要求概率，而dct的过程和jpeg一样。因为和jpeg一样,对二难矩阵处理了.Y=T*X*T'，Z=Y.*Mask，这样子,还有分成8*8子图像了;
3)example：
1、设三个函数f,g,h分别为 f(n)=100n^3+n^2+1000 , g(n)=25n^3+5000n^2 , h(n)=n^1.5+5000nlgn
请判断下列关系是否成立：
（1） f(n)=O(g(n))
（2） g(n)=O(f(n))
（3） h(n)=O(n^1.5)
（4） h(n)=O(nlgn)
这里我们复习一下渐近时间复杂度的表示法T(n)=O(f(n))，这里的"O"是数学符号，它的严格定义是"若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n)=O(f(n))表示存在正的常数C和n0 ,使得当n≥n0时都满足0≤T(n)≤C?f(n)。"用容易理解的话说就是这两个函数当整型自变量n趋向于无穷大时，两者的比值是一个不等于0的常数。这么一来，就好计算了吧。
◆ (1)成立。题中由于两个函数的最高次项都是n^3,因此当n→∞时，两个函数的比值是一个常数，所以这个关系式是成立的。
◆ （2）成立。与上同理。
◆ （3）成立。与上同理。
◆ （4）不成立。由于当n→∞时n^1.5比nlgn递增的快，所以h(n)与nlgn的比值不是常数，故不成立。
2、设n为正整数，利用大"O"记号，将下列程序段的执行时间表示为n的函数。
(1) i=1; k=0
while(i<n)
{ k=k+10*i;i++;
}
解答：T(n)=n-1， T(n)=O(n)， 这个函数是按线性阶递增的。
(2) x=n; // n>1
while (x>=(y+1)*(y+1))
y++;
解答：T(n)=n1/2 ，T(n)=O(n1/2)，最坏的情况是y=0，那么循环的次数是n1/2次，这是一个按平方根阶递增的函数。
(3) x=91; y=100;
while(y>0)
if(x>100)
{x=x-10;y--;}
else x++;
解答： T(n)=O(1)，这个程序看起来有点吓人，总共循环运行了1000次，但是我们看到n没有? 没。这段程序的运行是和n无关的，就算它再循环一万年，我们也不管他，只是一个常数阶的函数。
同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。

1、时间复杂度

（1）时间频度
一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

（2）时间复杂度
在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。

一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。

按数量级递增排列，常见的时间复杂度有：
常数阶O(1),对数阶O(log2n),线性阶O(n),
线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),...，
k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

2、空间复杂度
与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作:
S(n)=O(f(n))

我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模。讨论方法与时间复杂度类似，不再赘述。
（3）渐进时间复杂度评价算法时间性能
　　主要用算法时间复杂度的数量级(即算法的渐近时间复杂度)评价一个算法的时间性能。
【例3．7】有两个算法A1和A2求解同一问题，时间复杂度分别是T1(n)=100n2，T2(n)=5n3。
（1）当输入量n＜20时，有T1(n)＞T2(n)，后者花费的时间较少。
（2）随着问题规模n的增大，两个算法的时间开销之比5n3/100n2=n/20亦随着增大。即当问题规模较大时，算法A1比算法A2要有效地多。
它们的渐近时间复杂度O(n2)和O(n3)从宏观上评价了这两个算法在时间方面的质量。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分，而经常是将渐近时间复杂度T(n)=O(f(n))简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。
【例3．8】算法MatrixMultiply的时间复杂度一般为T(n)=O(n3)，f(n)=n3是该算法中语句(5)的频度。下面再举例说明如何求算法的时间复杂度。

【例3．9】交换i和j的内容。
      Temp=i;
      i=j;
      j=temp;

　　以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。
      如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。

【例3．10】变量计数之一。
(1) x=0;y=0;
(2) for(k-1;k<=n;k++)
(3)     x++;
(4) for(i=1;i<=n;i++)
(5)       for(j=1;j<=n;j++)
(6)         y++;

　　一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分。因此，以上程序段中频度最大的语句是(6)，其频度为f(n)=n2，所以该程序段的时间复杂度为T(n)=O(n2)。
　　当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。

【例3．11】变量计数之二。
(1) x=1;
(2) for(i=1;i<=n;i++)
(3)       for(j=1;j<=i;j++)
(4)           for(k=1;k<=j;k++)
(5)               x++;

　　该程序段中频度最大的语句是(5)，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析语句(5)的执行次数：

则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3)。

（4）算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。
【例3．12】在数值A[0..n-1]中查找给定值K的算法大致如下：
   (1)i=n-1;
          (2)while(i>=0&&(A[i]!=k))
      (3)     i--;
      (4)return i;

      此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关:
①若A中没有与K相等的元素，则语句(3)的频度f(n)=n；
②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。

（5）最坏时间复杂度和平均时间复杂度
　　最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。
      这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。
【例3．19】查找算法【例1・8】在最坏情况下的时间复杂度为T(n)=0(n)，它表示对于任何输入实例,该算法的运行时间不可能大于0(n)。
      平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。
      常见的时间复杂度按数量级递增排列依次为：常数0(1)、对数阶0(log2n)、线形阶0(n)、线形对数阶0(nlog2n)、平方阶0(n2)立方阶0(n3)、…、k次方阶0(nk)、指数阶0(2n)。显然，时间复杂度为指数阶0(2n)的算法效率极低，当n值稍大时就无法应用。
      类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。算法的时间复杂度和空间复杂度合称为算法的复杂度。